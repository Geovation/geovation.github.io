# Points of note

- Need same clustering algorithm on client & server.
- Don't need all the functionality ```serverComponents``` / ```serverComponentsStatic``` provide as we aren't sending the result to the client for rendering, we only want the clustering algorithm to run.
- The server needs to know the client border (LatLng), dimensions (pixels), zoom (max, min & current), devicePixelRatio and maxClusterRadius to match what's happening on the client.
- The Leaflet.markercluster algorithm is such that you get different clusters depending upon the order in which you add points (i.e. Markers) to the cluster group!  Make sure points are sorted the same way on client & server (i.e. by ID).
- We can only determine which cluster markers have been created by hooking into the iconCreateFunction. This runs asynchronously and the number of times it runs is not known before the first time it runs (hence ```this.clusterGroup._topClusterLevel._childClusters.length``` check).
- For each cluster, the minimum number of points we need to return is determined by the convex hull for that cluster (as this will be used as the geo polygon boundary to search for points if the cluster is clicked on). We therefore need some way of ignoring the points within the convex hull that are not themselves part of the convex hull. However, we also need to account for points that are not clustered. This is why we're using the hash keyed on the geohash of each point together with the hash keyed on the ID of each point (hashes are much faster to look up than elements within an array). We need to account for the fact that there may be more than one point at any geohash.
- We actually need to retrieve all the points one 'screen' in any direction from the current screen bounds, so that if a user grabs the screen at a corner and drags it to the opposite corner they see all the relevant clusters as they are dragging - otherwise clusters will suddenly appear once they stop dragging which will be confusing (and counter to the drag metaphor where we expect to see what is there when we drag).
- How do we get the data we need 'out' of the cluster rendering code? This code generates HTML so we insert the information we want in the generated HTML and parse the result to find what we need. Problem is that parsing assumes properly formed XML which HTML does not have to be. In fact, Leaflet creates image tags for points that are not clustered which do not have closing tags (because HTML doesn't require them) which causes the parsing to fail. As a consequence it is necessary to remove any 'img' tags from the DOM before returning the rendered HTML to the calling function.
- Don't forget that we first add all the ids as an unordered list to the rendered HTML just in case there are no resultant clusters (and `iconCreateFunction` doesn't get called). We then have to remove this unordered list and re-add it if clusters are present, after first removing all the points contained by the cluster from the list of ids and adding back those present in the convex hull.
- Even if we order the resultant sub-set of convex hulls the clusters will not be rendered the same way as if we returned all the results. This is because the algorithm for creating clusters is not only dependent upon order but also on location; our reduced set of results is in the same nominal order but in effect the locations are now jumbled up so we get a different result! We need to do things differently. Instead of relying on client-side clustering to render the locations for us we need to return a single point representing the centre of the cluster and an associated array of points that are the convex hull locations of the images for that cluster. We must override the mouse hover function to display the convex hull set as though it were the points contained by the cluster. What actually creates the cluster is a set containing the cluster centre and a clone of the cluster centre (otherwise we have to create a new icon representing clusters and display the centre point as an image using that icon - too much work!). In order for this to work we have to use a maxClusterRadius on the client that is half that of the server, otherwise our cluster centres may, themselves, be clustered!
- Why not just return the cluster bounds? Because they often overlap, meaning that some points are ambiguous as to which cluster they appear in (i.e. if we use the cluster bounds as a geoBoundary for ElasticSearch it may well return more results than are displayed in the cluster icon, confusing users).
- Discovered that using convex hulls to return the images within the convex hull doesn't work. Due, presumably, to rounding errors ElasticSearch decides that some of the points that define the convex hull no longer correspond to points within or on the boundary of the convex hull. The result is that only some of the contained points are returned, not all. In order to account for this I needed to make the convex hull very slightly bigger. I used the `geodesy` npm module to determine the distance and bearing of each point on the convex hull from the centroid of the convex hull. I then used the same module to create new points on the same bearing that were 0.5m further away from the centroid. This was sufficient to ensure that all points contained within the convex hull are returned from an ElasticSearch Geo-polygon search.
- There are occasionally instances where convex hulls overlap such that the number of points ElasticSearch considers to be contained in one of the convex hulls is greater than the number that Leaflet.MarkerCluster computes as being in the convex hull. There isn't much I can do about this, unfortunately (it's usually only a couple of extra points which is an acceptable margin of error)!
- In order to get animation between layers it is necessary to return some details about the next zoom level (i.e. zoom in). I've added a property `childClusters` to each cluster iterates over the clusters in the next zoom level down and adds the count and centroid (as convexHull) to the list of child clusters for the cluster in question. Unfortunately, we have to use half the maxClusterRadius on the client as on the server (otherwise the points representing the clusters may, themselves, be clustered) and this has the perverse effect of preventing many of the child clusters (which are centred on the centroid of their respective convexHulls) from being clustered with the parent with the result that they are displayed when we don't want them to be! To overcome this I convert the centroid of the parent and the location of the child into (x,y) coordinates and make sure that the distance between them (i.e. the hypoteneuse) is not larger than (maxClusterRadius -1) to ensure that they are clustered with their parent. If the distance is larger I reduce it to the limit value. In this way, although these clusters will not be fully animated they will be at least partially animated - enough to fool the eye, anyway.
No longer using half cluster radius on client - rather am adding a cluster group for each individual cluster. Child clusters are passed as count and center (parent also passed as center). Center is to reduce 'jerk' on zoom animation.  Also, now adding as child clusters images which will appear at the next zoom level (to prevent them 'just appearing'). This means that at higher zoom levels I'm actually sending more data than would otherwise be sent but at low zoom (where the number of points becomes an issue) compression kicks in.