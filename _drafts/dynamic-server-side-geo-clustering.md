# Points of note

- Need same clustering algorithm on client & server.
- Don't need all the functionality ```serverComponents``` / ```serverComponentsStatic``` provide as we aren't sending the result to the client for rendering, we only want the clustering algorithm to run.
- The server needs to know the client border (LatLng), dimensions (pixels), zoom (max, min & current), devicePixelRatio and maxClusterRadius to match what's happening on the client.
- The Leaflet.markercluster algorithm is such that you get different clusters depending upon the order in which you add points (i.e. Markers) to the cluster group!  Make sure points are sorted the same way on client & server (i.e. by ID).
- We can only determine which cluster markers have been created by hooking into the iconCreateFunction. This runs asynchronously and the number of times it runs is not known before the first time it runs (hence ```this.clusterGroup._topClusterLevel._childClusters.length``` check).
- For each cluster, the minimum number of points we need to return is determined by the convex hull for that cluster (as this will be used as the geo polygon boundary to search for points if the cluster is clicked on). We therefore need some way of ignoring the points within the convex hull that are not themselves part of the convex hull. However, we also need to account for points that are not clustered. This is why we're using the hash keyed on the geohash of each point together with the hash keyed on the ID of each point (hashes are much faster to look up than elements within an array). We need to account for the fact that there may be more than one point at any geohash.
- We actually need to retrieve all the points one 'screen' in any direction from the current screen bounds, so that if a user grabs the screen at a corner and drags it to the opposite corner they see all the relevant clusters as they are dragging - otherwise clusters will suddenly appear once they stop dragging which will be confusing (and counter to the drag metaphor where we expect to see what is there when we drag).
- How do we get the data we need 'out' of the cluster rendering code? This code generates HTML so we insert the information we want in the generated HTML and parse the result to find what we need. Problem is that parsing assumes properly formed XML which HTML does not have to be. In fact, Leaflet creates image tags for points that are not clustered which do not have closing tags (because HTML doesn't require them) which causes the parsing to fail. As a consequence it is necessary to remove any 'img' tags from the DOM before returning the rendered HTML to the calling function.
- Don't forget that we first add all the ids as an unordered list to the rendered HTML just in case there are no resultant clusters (and `iconCreateFunction` doesn't get called). We then have to remove this unordered list and re-add it if clusters are present, after first removing all the points contained by the cluster from the list of ids and adding back those present in the convex hull.
- Even if we order the resultant sub-set of convex hulls the clusters will not be rendered the same way as if we returned all the results. This is because the algorithm for creating clusters is not only dependent upon order but also on location; our reduced set of results is in the same nominal order but in effect the locations are now jumbled up so we get a different result! We need to do things differently. Instead of relying on client-side clustering to render the locations for us we need to return a single point representing the centre of the cluster and an associated array of points that are the convex hull locations of the images for that cluster. We must override the mouse hover function to display the convex hull set as though it were the points contained by the cluster. What actually creates the cluster is a set containing the cluster centre and a clone of the cluster centre (otherwise we have to create a new icon representing clusters and display the centre point as an image using that icon - too much work!). In order for this to work we have to use a maxClusterRadius on the client that is half that of the server, otherwise our cluster centres may, themselves, be clustered!
- Why not just return the cluster bounds? Because they often overlap, meaning that some points are ambiguous as to which cluster they appear in (i.e. if we use the cluster bounds as a geoBoundary for ElasticSearch it may well return more results than are displayed in the cluster icon, confusing users).
- Discovered that using convex hulls to return the images within the convex hull doesn't work. Due, presumably, to rounding errors ElasticSearch decides that some of the points that define the convex hull no longer correspond to points within or on the boundary of the convex hull. The result is that only some of the contained points are returned, not all. In order to account for this I needed to make the convex hull very slightly bigger. I used the `geodesy` npm module to determine the distance and bearing of each point on the convex hull from the centroid of the convex hull. I then used the same module to create new points on the same bearing that were 0.5m further away from the centroid. This was sufficient to ensure that all points contained within the convex hull are returned from an ElasticSearch Geo-polygon search. UPDATE: Removed this code. Now, converting each point in the convex hull into it's equivalent bounding box (1m square) and creating a new convex hull of these points. Works like a dream, even for complex hulls with only two points.
- There are occasionally instances where convex hulls overlap such that the number of points ElasticSearch considers to be contained in one of the convex hulls is greater than the number that Leaflet.MarkerCluster computes as being in the convex hull. There isn't much I can do about this, unfortunately (it's usually only a couple of extra points which is an acceptable margin of error)!
- In order to get animation between layers it is necessary to return some details about the next zoom level (i.e. zoom in). I've added a property `childClusters` to each cluster iterates over the clusters in the next zoom level down and adds the count and centroid (as convexHull) to the list of child clusters for the cluster in question. Unfortunately, we have to use half the maxClusterRadius on the client as on the server (otherwise the points representing the clusters may, themselves, be clustered) and this has the perverse effect of preventing many of the child clusters (which are centred on the centroid of their respective convexHulls) from being clustered with the parent with the result that they are displayed when we don't want them to be! To overcome this I convert the centroid of the parent and the location of the child into (x,y) coordinates and make sure that the distance between them (i.e. the hypoteneuse) is not larger than (maxClusterRadius -1) to ensure that they are clustered with their parent. If the distance is larger I reduce it to the limit value. In this way, although these clusters will not be fully animated they will be at least partially animated - enough to fool the eye, anyway.
No longer using half cluster radius on client - rather am adding a cluster group for each individual cluster. Child clusters are passed as count and center (parent also passed as center). Center is to reduce 'jerk' on zoom animation.  Also, now adding as child clusters images which will appear at the next zoom level (to prevent them 'just appearing'). This means that at higher zoom levels I'm actually sending more data than would otherwise be sent but at low zoom (where the number of points becomes an issue) compression kicks in.
Expanding map bounds 'one unit' in all directions wasn't working at lower zoom levels (i.e. more of the map can be seen). I was using spherical coordinates to calculate the distance and direction of the top right corner from the bottom left and using this to expand the bounds. As the bounds expand so this starts 'wrapping' around the earth causing problems. As an alternative, I converted lat/lng into their equivalent map tiles and used these to expand bounds (limiting them to +/- 83 degrees latitude and +/- 170 degrees longitude). This was done server-side, but I realised that using map tiles gives an element of repeatability (any given tile combination applies to a specific area, not to a specific lat/lng) which facilitates caching of URLs. Consequently, I moved this client-side to increase caching.
I noticed that at certain zoom levels in certain locations all the images were being returned as well as clusters of those images. It turns out that for some unknown reason the leaflet markercluster can fail to create an icon for one or more child clusters, which was causing the issue (I look for the final cluster before deleting the image tags from the resultant dom on the server - if the final child cluster never runs its iconCreationFunction the deletion won't occur). To fix this I had to add markers to the cluster group and then check each 'first-level' child cluster to see if it had marked `_iconNeedsUpdate` as false. If not, I manually ran the createIcon() function. This is a hack but without being able to see why this was happening it is the best solution I could come up with.
Discovered a problem with the hack above. The `HTMLElement.createdCallback` was not returning a promise to `serverComponent.renderPage` as it should to allow for asynchronous rendering (such as that employed by ClusterMarker) with the result that I was returning results too early before rendering was complete. I wrapped `createdCallback` in a promise to solve this issue and found that I was creating another by forcing rendering of the icons too soon - I was getting two requests to render the icon for certain clusters in certain zoom levels, presumably because the asynchronous rendering was being triggered immediately after the forced rendering. I added a timeout before forcing rendering together with a hash of the `_leaflet_id`'s of the processed clusters to ensure that each cluster is rendered only once. This removed nearly all bad behaviour when rendering clusters.
Discovered a significant memory leak. For some reason the `MapElement.createdCallback` was holding references to all it's variables after it had completed and it's context was closed. The culprit was `leaflet-for-server` which was holding on to references. I presume this has something to do with using `SandboxedModule` but I don't yet know exactly what or why. The problem was solved by explicitly releasing all references to object properties by setting them to `null`.

-expose_gc
import * as heapdump from "heapdump";
const takeSnapshot = (message: string) => {
    if (global.gc) {
        global.gc();
    } else {
        console.log("can't garbage collect");
    }
    console.log(message + " " + process.memoryUsage().heapUsed);
};